# 1. Отдача морды (http / css / js)
## Контекст
\-
## Решение
- Отдавать морду из отдельного сервиса / приложения
    - `PointerTracking.Web` неймспейс
## Последствия
- Меньше кода тестить и проверять
    - тк апи сервис не включает в себя код для отдачи файлов
- Проще масштабировать
    - тк апи дольше выполняет запросы и можно скейлить поды только с апи
- Проще разрабатывать
    - тк не нужно пересобирать морду при изменении бека
- Сложнее тестировать все приложения
    - тк нужно запустить два приложения / контейнера


# 2. Свагер вместо дефолтного опенапи
## Контекст
\-
## Решение
\-
## Последствия
- Не нужно читать жсон объект
- Можно послать простой запрос ручками

# 3. Дто с инфой от фронта
## Контекст
```
который собирает координаты движения мышки при ее движении
в формате [X,Y,T],
где X,Y - координаты, T - время события.
```
## Решение
```json
{
    "X": [{double}],
    "Y": [{double}],
    "T": [{long}]
}
```
## Последствия
- Размер сериализованного дто меньше
    - чем если хранить массив объектов
- Нужна дополнительная валидация
    - на одинаковое кол-во элементов в массивах

# 5. Какую дб использовать
## Решение
- Для начала - sqlite
## Контекст
```
массив координат движения мышки, сохраненный ранее,
должен отправляться на бекенд
и сохраняться через Entity в таблицу произвольной базы данных
```
## Почему
- Не нужно развертывать докер
  - прототипирование будет быстрее
    

# 4. Где хранить миграции
## Контекст
- Нужны миграции
## Решение
- Будут храниться отдельной асембле `PointerTracking.Migrations`
## Почему
- У меня есть опыт работы таким подходом
# 1. [Инвалидировано #6] ~~Фронтенд отдается из отдельного сервиса~~
## Почему
- Меньше кода тестить и проверять
    - тк апи сервис не включает в себя код для отдачи файлов
- Проще масштабировать
    - тк апи дольше выполняет запросы и можно скейлить поды только с апи
- Проще разрабатывать
    - тк не нужно пересобирать морду при изменении бека
- Сложнее тестировать все приложения
    - тк нужно запустить два приложения / контейнера


# 2. Свагер вместо дефолтного опенапи
## Почему
- Не нужно читать жсон объект
- Можно послать простой запрос ручками

# 3. Дто с инфой от фронта
## Контекст
```
который собирает координаты движения мышки при ее движении
в формате [X,Y,T],
где X,Y - координаты, T - время события.
```
## Решение
```json
{
    "X": [{double}],
    "Y": [{double}],
    "T": [{long}]
}
```
## Почему
- Размер сериализованного дто меньше
    - чем если хранить массив объектов
- Нужна дополнительная валидация
    - на одинаковое кол-во элементов в массивах

# 5. Sqlite драйвер для efcore
## Контекст
```
массив координат движения мышки, сохраненный ранее,
должен отправляться на бекенд
и сохраняться через Entity в таблицу произвольной базы данных
```
## Почему
- Не нужно развертывать докер
  - прототипирование будет быстрее
    

# 4. Миграции хранятся в отдельной асембле `PointerTracking.Migrations`
## Почему
- У меня есть опыт работы таким подходом

# 5. [Инвалидировано #6] ~~Ручка на `PointerTracking.Web` с адресом `PointerTracking.Api`~~
## Контекст
- Тк `Web` и `Api` это разные сервисы на разных портах, веб должен как-то сказать фронту куда звонить
## Почему так
- Mvc view, - слишком громоздкое решение для урл Апи во фронт
- Минимальный апи - дешево и сердито
  - но фронт-енду с таким решением работать было бы ОЧ не удобно
    - будущее решение: reverse proxy: web и api спрятаны на одном url-е

# 6. Мердж `PointerTracking.Web` и `PointerTracking.Api`
## Почему
- CORS

# 7. Postgres дб
## Почему
- Тесты не ловят Sqlite файл